<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自动化测试-01：了解</title>
    <url>/2020/10/16/AutoTest01/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>了解测试内容分类</li>
<li>了解测试框架</li>
<li>相关视频教程</li>
</ul>
<a id="more"></a>
<h3 id="测试内容分类"><a href="#测试内容分类" class="headerlink" title="测试内容分类"></a>测试内容分类</h3><ul>
<li>从软件测试的实践过程看：单元测试、集成测试、确认测试、系统测试、验收测试</li>
<li>从软件测试的方法策略看：白盒测试、黑盒测试、灰盒测试</li>
<li>从软件测试的测试视角看：功能测试、性能测试、兼容性测试、安全测试、探索性测试</li>
<li>从软件测试的技术程度看：手工测试、自动化测试、测试开发</li>
</ul>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><ul>
<li>Python/PHP/Java/C#/JavaScprit/Ruby + Selenium/Appium + 单元测试框架：开源功能自动化测试方案</li>
<li>Python + Macaca：阿里巴巴  自动化测试方案</li>
<li>JavaScript + TestCafe，DevExpress： 开源功能自动化测试方案</li>
<li>Python/Java/C#/JavaScprit/Ruby + Gauge： 一款开源的功能自动化测试方案</li>
<li>JavaScript + Postman：免费的Web接口功能自动化测试</li>
<li>Groovy + SoapUI：开源的Web接口功能自动化测试方案</li>
<li>更多<ul>
<li>Selenium：<a href="http://www.selenium.org.cn/category/use">web测试工具</a></li>
<li>Appium: web、原生、混合应用都能测试</li>
<li>JMeter：软件压测工具</li>
</ul>
</li>
</ul>
<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><ul>
<li><a href="https://www.51zxw.net/list.aspx?page=2&amp;cid=670">Appium自动化测试视频教程</a></li>
<li><a href="https://sutune.me/2018/04/15/appium/">Appium简介</a></li>
<li><a href="https://hllgithub.github.io/2018/09/09/Appium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">Appium自动化测试介绍和使用说明</a></li>
<li><a href="http://www.selenium.org.cn/category/use">Selenium</a></li>
<li><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/">Selenium + python 中文文档</a></li>
<li><a href="https://macacajs.github.io/zh/guide/#%E9%9B%86%E6%88%90%E5%92%8C%E8%9E%8D%E5%90%88">Macaca</a></li>
<li><a href="https://yq.aliyun.com/articles/398697">Macaca-iOS入门那些事</a></li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/36896449">一分钟了解自动化测试</a></li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化测试-02：实践</title>
    <url>/2020/10/22/AutoTest02/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>环境搭建: Appium 环境、Android 环境、Python 环境、夜神模拟器</li>
<li>Android APP 测试 </li>
</ul>
<a id="more"></a>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li>Appium 环境<ul>
<li>安装：Appium Desktop (Server) <a href="https://github.com/appium/appium-desktop/releases">下载地址</a></li>
<li>安装：Appium-Python-Client (Client) <a href="https://pypi.org/project/Appium-Python-Client/">教程</a></li>
</ul>
</li>
<li>Android 环境：<ul>
<li>下载安装JDK <a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">下载地址</a></li>
<li>下载Android SDK <a href="https://developer.android.com/studio">下载地址</a></li>
<li>配置JAVA和Android环境变量 <a href="https://www.jianshu.com/p/a9e80bb782af">教程</a></li>
</ul>
</li>
<li>Python 环境：<ul>
<li>首先：<a href="https://www.python.org/downloads/">下载安装Python</a></li>
<li>此次：安装Appium Python库, 命令: pip install -U Appium-Python-Client—python <a href="https://pypi.org/project/Appium-Python-Client/">安装教程</a></li>
<li>最后：安装Python IDE <a href="https://www.jetbrains.com/pycharm/download/#section=windows">pycharm下载</a></li>
</ul>
</li>
<li>夜神模拟器：<a href="https://www.yeshen.com/">下载安装</a></li>
</ul>
<h3 id="Android-APP-测试"><a href="#Android-APP-测试" class="headerlink" title="Android APP 测试"></a>Android APP 测试</h3><ul>
<li><p>常用命令：</p>
<ul>
<li>获取联机设备名称：adb devices</li>
<li>与设备建立连接：adb connect ip:port (提示：使用adb devices 显示设备的ip和端口)</li>
<li><p>获取APP包名和启动名：adb shell dumpsys window  windows | findstr mFocusedApp (提示：使用模拟器或手机,打印需测试的APP 保持显示在当前屏幕后，在cmd中输入此命令回车，假如输出结果如下)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  adb shell dumpsys window  windows | findstr mFocusedApp</span><br><span class="line">mFocusedApp&#x3D;AppWindowToken&#123;e84eb4f token&#x3D;Token&#123;1260a29 ActivityRecord&#123;16e4bb0 u0 com.guide.custom&#x2F;com.anyapps.Activity.AALaunch t12&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">包名：com.guide.custom</span><br><span class="line">启动Activity名：com.anyapps.Activity.AALaunch</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>调试步骤：</p>
<ol>
<li>启动夜神模拟器，获取相关信息<ul>
<li>获取设备号IP和Port: cmd-&gt;adb devices (如果不显示请检查环境配置)</li>
<li>与设备建立连接：adb connect 127.0.0.1:62001</li>
<li>系统版本：系统应用-&gt;设置-&gt;版本</li>
</ul>
</li>
<li>打开程序包(拿系统Setting打比方)，获取包名和启动Activity名：adb shell dumpsys window  windows | findstr</li>
<li>启动Appium，创建Server&lt;-&gt;会话<ul>
<li>Start Server -&gt; 点击搜索图标 -&gt; 根据1、2获取信息，填写对应信息，我的如下<br><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/20201025-001.png" alt=""></li>
<li>创建会话成功后，效果图如下：(此时可以获取原生布局元素了)<br><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/20201025224614.png" alt=""></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul>
<li><a href="https://www.51zxw.net/list.aspx?page=2&amp;cid=670#!fenye=2">Appium自动化测试教程</a></li>
<li><a href="http://appium.io/docs/cn/writing-running-appium/caps/index.html">Appium 参数说明</a></li>
</ul>
<blockquote>
<p>最后：其他平台APP调试应该类似，以后再尝试吧 ~</p>
</blockquote>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-03：Web自动化测试【打开Chrome百度搜索Selenium】</title>
    <url>/2020/11/03/AutoTest03/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>环境准备</li>
<li>案例：打开Chrome百度搜索Selenium</li>
<li>原理总结</li>
</ul>
<a id="more"></a>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol>
<li>Win10</li>
<li>Chrome 84.0.4147.135</li>
<li>ChromeDriver 84.0.4147.30<ol>
<li>关闭Chrome更新，避免不停换驱动</li>
<li>下载Chrome对应版本ChromeDriver驱动<a href="https://chromedriver.chromium.org/downloads">下载地址</a></li>
<li>将ChromeDriver 放到Python安装目录下. 比如：C:\Users\Administrator\AppData\Local\Programs\Python\Python39</li>
</ol>
</li>
<li>Python 3.9.0</li>
<li>Selenium 3.141.0<br> 安装命令：pip install selenium (提示：如果执行报错，请检查python环境变量配置)</li>
</ol>
<h3 id="案例：打开Chrome百度搜索Selenium"><a href="#案例：打开Chrome百度搜索Selenium" class="headerlink" title="案例：打开Chrome百度搜索Selenium"></a>案例：打开Chrome百度搜索Selenium</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import  webdriver</span><br><span class="line"># 使用Chrome驱动</span><br><span class="line">driver &#x3D; webdriver.Chrome()</span><br><span class="line"># 让浏览器全屏</span><br><span class="line">driver.maximize_window()</span><br><span class="line"># 打开百度</span><br><span class="line">driver.get(&quot;https:&#x2F;&#x2F;baidu.com&quot;)</span><br><span class="line"># 找到百度搜索框元素</span><br><span class="line">input &#x3D; driver.find_element_by_id(&quot;kw&quot;)</span><br><span class="line"># 往输入框中输入搜索关键词&quot;selenium&quot;</span><br><span class="line">input.send_keys(&quot;selenium&quot;)</span><br><span class="line"># 点击百度一下按钮搜索</span><br><span class="line">search &#x3D; driver.find_element_by_id(&quot;su&quot;)</span><br><span class="line">search.click()</span><br></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote>
<p>其实原理就是 Python 通过Selenium 调用浏览器驱动接口，然后驱动Driver接口操作Web中元素进行交互</p>
</blockquote>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul>
<li><a href="https://selenium-python-zh.readthedocs.io/en/latest/index.html">Selenium-Python中文文档</a></li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-04：AppWeb自动化测试【打开App切换WebView登录】</title>
    <url>/2020/11/04/AutoTest04/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>环境准备</li>
<li>测试步骤</li>
<li>案例代码</li>
</ul>
<a id="more"></a>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol>
<li>NodeJS v12.13.1</li>
<li>JDK 1.8.0_191</li>
<li>Android SDK </li>
<li>Appium-Python-Client </li>
</ol>
<blockquote>
<p>具体教程请看: <a href="https://yanxuewen.cn/2020/10/22/AutoTest02/">自动化测试-02：实践</a></p>
</blockquote>
<h3 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h3><ol>
<li>AppWebView开启调试模式： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setWebContentsDebuggingEnabled(true);</span><br></pre></td></tr></table></figure></li>
<li>获取Android Chrome 版本： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am start -a android.intent.action.VIEW -d  https:&#x2F;&#x2F;liulanmi.com&#x2F;labs&#x2F;core.html</span><br></pre></td></tr></table></figure></li>
<li>根据Android Chrome版本，下载对应ChromeDriver驱动 <a href="https://chromedriver.chromium.org/downloads">下载地址</a></li>
<li>将下载的ChromeDriver Copy 至 Appium 目录，比如我的Appium目录： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Appium\resources\app\node_modules\appium\node_modules\appium-chromedriver\chromedriver\win</span><br></pre></td></tr></table></figure></li>
<li>启动APP后并跳转App内嵌的WebView页面，使用Chrome获取WebView中的元素 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开Chrome </span><br><span class="line">地址栏输入：chrome:&#x2F;&#x2F;inspect</span><br></pre></td></tr></table></figure>
 如下图所示：<br> <img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/20201105212810.png" alt=""></li>
</ol>
<h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 案例：自动化测试-登录</span><br><span class="line"></span><br><span class="line">from appium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">desired_caps &#x3D; &#123;&#125;</span><br><span class="line">desired_caps[&quot;platformName&quot;] &#x3D; &quot;android&quot;</span><br><span class="line">desired_caps[&quot;platformVersion&quot;] &#x3D; &quot;7.1.2&quot;</span><br><span class="line">desired_caps[&quot;deviceName&quot;] &#x3D; &quot;127.0.0.1:62001&quot;</span><br><span class="line">desired_caps[&quot;appPackage&quot;] &#x3D; &quot;com.guide.custom&quot;</span><br><span class="line">desired_caps[&quot;appActivity&quot;] &#x3D; &quot;com.anyapps.Activity.AALaunch&quot;</span><br><span class="line">desired_caps[&quot;noReset&quot;] &#x3D; &quot;true&quot;</span><br><span class="line">desired_caps[&quot;autoGrantPermissions&quot;] &#x3D; &quot;true&quot;</span><br><span class="line">desired_caps[&#39;chromeOptions&#39;] &#x3D; &#123;&quot;w3c&quot;:False&#125;</span><br><span class="line">desired_caps[&#39;showChromedriverLog&#39;] &#x3D; True</span><br><span class="line"></span><br><span class="line">driver &#x3D; webdriver.Remote(&#39;http:&#x2F;&#x2F;localhost:4723&#x2F;wd&#x2F;hub&#39;, desired_caps)</span><br><span class="line"></span><br><span class="line">view_context &#x3D; &quot;WEBVIEW_com.guide.custom&quot;</span><br><span class="line">driver.switch_to.context(view_context)</span><br><span class="line">time.sleep(5)</span><br><span class="line">print(driver.current_context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取账号和密码元素，输入账号密码</span><br><span class="line">inputAccount &#x3D; driver.find_element_by_id(&quot;account&quot;)</span><br><span class="line">inputAccount.send_keys(&#39;186xxxxxxx&#39;)</span><br><span class="line">inputPassword &#x3D; driver.find_element_by_id(&quot;password&quot;)</span><br><span class="line">inputPassword.send_keys(&#39;123456&#39;)</span><br><span class="line"># 获取登录元素，点击登录</span><br><span class="line">loginBtn &#x3D; driver.find_element_by_class_name(&#39;confirmDisable&#39;)</span><br><span class="line">loginBtn.click()</span><br></pre></td></tr></table></figure>
<h3 id="Appium-调试App-原理图"><a href="#Appium-调试App-原理图" class="headerlink" title="Appium 调试App 原理图"></a>Appium 调试App 原理图</h3><p><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/QQ%E6%88%AA%E5%9B%BE20201105213544.png" alt=""></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul>
<li><a href="https://selenium-python-zh.readthedocs.io/en/latest/index.html">Selenium-Python中文文档</a></li>
<li><a href="https://github.com/appium/appium/issues/13306">Fail to locate an web element using “findElement” on Android</a></li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
        <tag>Appnium</tag>
      </tags>
  </entry>
  <entry>
    <title>Github + Hexo + Next 搭建个人博客网站</title>
    <url>/2020/09/29/BuildBlog/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>搭建步骤</li>
<li>安装环境</li>
<li>图床加速、集成Gitalk、集成Valine </li>
<li>绑定域名、版权配置、赞赏、站点加速等</li>
</ul>
<blockquote>
<p>搭建原因：几年前一直在CSDN写博客，经常用心写的文章，结果过一段时间文章关联的图片全部丢失，给他们反馈无果，图片丢失也找不回。后面就转用印象笔记，几年下来记录了不少笔记，但是发现还是缺少一个互动的环节，不知道自己写的笔记有没有问题，没法与他人发生碰撞。想快速产生好的想法或者更好的解决方案，看到网上不少朋友都写在自己博客网站上，于是就决定自己也搭一个，一来记录自己成长，二来与大家互动让自己的知识得到升华，而且个人博客也显的逼格更高。 呵呵~  以下是我零碎2~3天搭自己博客网站的步骤，希望能给后面的人提供帮助。</p>
</blockquote>
<a id="more"></a>
<h2 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h2><hr>
<h3 id="Github-创建博客仓库"><a href="#Github-创建博客仓库" class="headerlink" title="Github 创建博客仓库"></a>Github 创建博客仓库</h3><p>在 GitHub 新建一个仓库（Repository），名称为 {username}.github.io，注意这个名比较特殊，必须要是 github.io 为后缀结尾的。比如：aa4790139.github.io</p>
<hr>
<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>在本机安装<a href="https://nodejs.org/zh-cn/download/">Node.js</a></p>
<hr>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;d&#x2F;Work&#x2F;Projects&#x2F;PotterBlog</span><br><span class="line">cd &#x2F;d&#x2F;Work&#x2F;Projects&#x2F;PotterBlog</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="初始化Hexo项目"><a href="#初始化Hexo项目" class="headerlink" title="初始化Hexo项目"></a>初始化Hexo项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果出现以下情况报错：<br><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/1.png" alt=""></p>
<p>  解决办法：关闭npm 的https</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set strict-ssl false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="编译生成-amp-本地启动"><a href="#编译生成-amp-本地启动" class="headerlink" title="编译生成&amp;本地启动"></a>编译生成&amp;本地启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>等启动完后浏览器打开<a href="http://localhost:4000">http://localhost:4000</a>，看到hello world 博客页面，说明你成功）</p>
<hr>
<h3 id="切换主题为Next"><a href="#切换主题为Next" class="headerlink" title="切换主题为Next"></a>切换主题为Next</h3><ul>
<li><p>首先：clone next 主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次：修改项目根目录下的 _config.yml，找到theme字段，更改为next即可</p>
</li>
<li><p>最后：修改主题next的默认的相关配置，主题配置文件路径：themes/next/_config.yml (<br>具体怎么配置看这篇文章相关部分即可：<a href="https://www.cxyxiaowu.com/6407.html">https://www.cxyxiaowu.com/6407.html</a> </p>
</li>
</ul>
<hr>
<h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><ul>
<li><p>命令：(提示：运行如下命令后，文章会生成到source/_posts下)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new hello-world</span><br></pre></td></tr></table></figure>
</li>
<li><p>文章开头格式规范：(提示：按此格式方便编译识别标题、时间、类别等)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标题 # 自动创建，如 hello-world</span><br><span class="line">tags: </span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br><span class="line">- 标签3</span><br><span class="line">categories:</span><br><span class="line">- 分类1</span><br><span class="line">- 分类2</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="创建Github-编写Markdown文章的图床"><a href="#创建Github-编写Markdown文章的图床" class="headerlink" title="创建Github 编写Markdown文章的图床"></a>创建Github 编写Markdown文章的图床</h3><ol>
<li>github 创建BlogPicBed 仓库</li>
<li><a href="https://docs.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token">创建个人访问令牌</a></li>
<li><a href="https://github-production-release-asset-2e65be.s3.amazonaws.com/113965016/bc669d80-3b9c-11ea-9c36-8274348f10a9?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20200923%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20200923T014847Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=64a969201f2341629756cedfb055010b0262aec31d37fddc06c9fdf6ac56618a&amp;X-Amz-SignedHeaders=host&amp;actor_id=9338717&amp;key_id=0&amp;repo_id=113965016&amp;response-content-disposition=attachment%3B%20filename%3DPicGo-Setup-2.2.2.exe&amp;response-content-type=application%2Foctet-stream">下载PicGo</a> (目的：利用此工具上传图片至Github创建的BlogPicBed仓库中)</li>
<li>PicGo 配置成Github,如下图所示<br><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/2.png" alt=""></li>
<li>利用PicGo 上传一张图片，然后去BlogPicBed仓库的img文件夹找到你刚刚上传的图片，然后右键复制图片链接地址</li>
<li>使用Github 图床仓库的图片地址(提示：复制的图片地址是不带raw参数的，所以需要手动在地址后面拼”?raw=true” 否则图片不会显示)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如：![](https:&#x2F;&#x2F;github.com&#x2F;aa4790139&#x2F;BlogPicBed&#x2F;blob&#x2F;master&#x2F;img&#x2F;2.png?raw&#x3D;true)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用jsdelivr CDN加速图床： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;github账号&#x2F;图床仓库名@版本&#x2F;仓库图片相对路径</span><br><span class="line">比如：https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;aa4790139&#x2F;BlogPicBed@master&#x2F;img&#x2F;2.png</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<hr>
<h3 id="集成Gitalk"><a href="#集成Gitalk" class="headerlink" title="集成Gitalk"></a>集成Gitalk</h3><ol>
<li>获取GitHub OAuth授权(参考文章：<a href="https://www.ruanyifeng.com/blog/2019/04/github-oauth.html">GitHub OAuth 第三方登录示例教程</a>)</li>
<li>GitHub 创建留言仓库BlogGitTalk(注意：此仓库必须为公开仓库，不能为私有仓库)</li>
<li>themes/_config.yml 找到gitalk，配置如下样子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: github账号 # GitHub repo owner</span><br><span class="line">  repo: BlogGitTalk # Repository name to store issues</span><br><span class="line">  client_id: GitHub OAuth授权申请下来的client_id # GitHub Application Client ID</span><br><span class="line">  client_secret: GitHub OAuth授权申请下来的client_secret # GitHub Application Client Secret</span><br><span class="line">  admin_user: github账号 # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="集成Valine"><a href="#集成Valine" class="headerlink" title="集成Valine"></a>集成Valine</h3><ol>
<li>注册leancloud账号<a href="https://www.leancloud.cn/"></a></li>
<li>leancloud 创建应用</li>
<li>themes/_config.yml 找到valine，配置如下样子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: leancloud 创建的应用AppID # Your leancloud application appid</span><br><span class="line">  appkey: leancloud 创建的应用appkey # Your leancloud application appkey</span><br><span class="line">  notify: false # Mail notifier</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: Just go go # Comment box placeholder</span><br><span class="line">  avatar: mm # Gravatar style</span><br><span class="line">  guest_info: nick,mail,link # Custom comment header</span><br><span class="line">  pageSize: 10 # Pagination size</span><br><span class="line">  language: zh-cn # Language, available values: en, zh-cn</span><br><span class="line">  visitor: true # Article reading statistic</span><br><span class="line">  comment_count: true # If false, comment count will only be displayed in post page, not in home page</span><br><span class="line">  recordIP: false # Whether to record the commenter IP</span><br><span class="line">  serverURLs: # When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span><br><span class="line">  #post_meta_order: 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="部署至Github"><a href="#部署至Github" class="headerlink" title="部署至Github"></a>部署至Github</h3><ul>
<li>打开blog根目录下的_config.yml配置,找到Deployment, 配置参考如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:github用户名&#x2F;github用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安装hexo-deployer-git 部署插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署</p>
<ul>
<li>在根目录新建部署脚本deploy.sh，内容如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li>
<li><p>运行部署命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh deploy.sh</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><ol>
<li>阿里云购买域名: <a href="https://oss.console.aliyun.com/"></a></li>
<li>获取github上博客项目域名的ip<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping github用户名.github.io</span><br></pre></td></tr></table></figure></li>
<li>阿里云平台域名绑定博客域名ip(第2步ping出来的ip)<br><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/3.png" alt=""></li>
</ol>
<hr>
<h3 id="版权配置"><a href="#版权配置" class="headerlink" title="版权配置"></a>版权配置</h3><ol>
<li>next/_config.yum 找到creative_commons</li>
<li>配置成如下样子：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true</span><br><span class="line">  language: zh-CN</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="QQ交流平台："><a href="#QQ交流平台：" class="headerlink" title="QQ交流平台："></a>QQ交流平台：</h3><p>hexo next主题交流：1076692090</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul>
<li><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo博客搭建之在文章中插入图片</a></li>
<li><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">Hexo使用攻略-添加分类及标签</a></li>
<li><a href="https://www.cnblogs.com/alex-zen/p/11203544.html#%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87">Markdown必备-本地图片快速上传至图床</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2019/04/github-oauth.html">GitHub OAuth 第三方登录示例教程</a></li>
<li><a href="https://poplite.xyz/post/2018/05/03/how-to-enable-https-for-custom-domain-on-github-pages.html">Github Pages 开始为自定义域名提供 HTTPS 支持</a></li>
<li><a href="https://github.com/jsdelivr/jsdelivr#usage">JSdelivr 使用说明</a></li>
<li><a href="https://www.itrhx.com/2019/02/10/A18-free-cdn/">免费CDN：jsDelivr + Github</a></li>
</ul>
<hr>
<h3 id="特别致谢："><a href="#特别致谢：" class="headerlink" title="特别致谢："></a>特别致谢：</h3><ul>
<li>cxyxiaowu ：<a href="https://www.cxyxiaowu.com/6407.html">https://www.cxyxiaowu.com/6407.html</a></li>
<li>Lining Wei ：<a href="https://weilining.github.io/">https://weilining.github.io/</a></li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>结束《皇室战争》之旅</title>
    <url>/2020/11/02/Game01/</url>
    <content><![CDATA[<h3 id="一款又爱又恨的游戏"><a href="#一款又爱又恨的游戏" class="headerlink" title="一款又爱又恨的游戏"></a>一款又爱又恨的游戏</h3><ul>
<li>爱：<ol>
<li>这游戏UI和画质都做得非常精美，原画的细节做得非常逼真</li>
<li>3分钟一场战斗，游戏时间设置的完美</li>
<li>操作简单，容易上手</li>
</ol>
</li>
<li>恨:<ol>
<li>3分钟一场战斗，导致你蹲个坑都可以玩几局，有时输能让你蹲出半个多小时，最后起来酸的不行</li>
<li>部落战匹配规则做得不好，分段6K左右自己卡等只有10级，结果给你匹配满级的来对付你，你技术再好也是以卵击石</li>
<li>商店不断推出活动引诱你充值，看到你要啥卡牌、是没有金币还是没有宝石，就给你推对应的活动</li>
<li>影响与家人的关系，有时候连输好几把，家人跟我聊天，我说话很冲，导致跟对方吵起来</li>
<li>不间断活动、每天对战，让你控制不住不玩，不停想上分，影响工作和学习</li>
</ol>
</li>
</ul>
<a id="more"></a>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ol>
<li>对方出的每张卡都记住，等全部8张卡出完，再想怎么用当前的卡组对付它</li>
<li>未知对方卡组，尽量使用小费过牌，等待摸清对方卡组再出手</li>
<li>排兵布阵不能全部放到一块，要分散放，不然被对面一个法术全部打中</li>
</ol>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote>
<p>要升级的卡组已升满，没有玩下去的欲望了，本想这个赛季冲个6500+，结果没多少时间打，中午打了一个多小时，结果卡住6150上不去了，那就让他停留在6150结束这段旅程。接下来开启新的篇章，好好学习、好好工作，这样才能有好的未来</p>
</blockquote>
<p><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/222.png" alt=""></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>皇室战争</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 与 JS 之间Gzip互通</title>
    <url>/2020/12/16/JS01/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>JS 压缩 Gzip demo</li>
<li>JS 压缩 Gzip + base64 demo</li>
<li>JS 解压 CSharp 的 Gzip demo</li>
<li>JS 解压 CSharp 的 base64 + gzip</li>
<li>CSharp 压缩 Gzip demo</li>
<li>CSharp 压缩 Gzip + base64 demo</li>
<li>CSharp 解压 JS 的 Gzip demo</li>
<li>CSharp 解压 JS 的 base64 + gzip</li>
<li>Base64 encode 和 decode </li>
</ul>
<h3 id="源码地址："><a href="#源码地址：" class="headerlink" title="源码地址："></a>源码地址：</h3><p><a href="https://github.com/aa4790139/GzipSample">https://github.com/aa4790139/GzipSample</a></p>
<a id="more"></a>
<h3 id="GZip-文件结构图"><a href="#GZip-文件结构图" class="headerlink" title="GZip 文件结构图"></a>GZip 文件结构图</h3><p><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/20201217210101.jpg" alt=""></p>
<!--more-->
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul>
<li><a href="https://stackabuse.com/encoding-and-decoding-base64-strings-in-node-js/">Encoding and Decoding Base64 Strings in Node.js</a></li>
<li><a href="https://zh.wikipedia.org/wiki/DEFLATE">DEFLATE</a></li>
<li><a href="https://stackoverflow.com/questions/246801/how-can-you-encode-a-string-to-base64-in-javascript">How can you encode a string to Base64 in JavaScript?</a></li>
<li><a href="https://stackoverflow.com/questions/3195865/converting-byte-array-to-string-in-javascript">Converting byte array to string in javascript</a></li>
<li><a href="https://www.jianshu.com/p/c5df0156b229">Array.prototype.slice.call()方法详解</a></li>
<li><a href="https://stackoverflow.com/questions/7056925/how-does-array-prototype-slice-call-work">how does Array.prototype.slice.call() work?
</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">JS按位操作符</a></li>
<li><a href="https://www.iditect.com/how-to/58717282.html">Remove trailing zeros from byte[]</a></li>
<li><a href="https://stackoverflow.com/questions/17191945/conversion-between-utf-8-arraybuffer-and-string">Conversion between UTF-8 ArrayBuffer and String</a></li>
<li><a href="https://tool.oschina.net/commons?type=4">ASCLL对照表</a></li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>压缩</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Gzip</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密和非对称加密的应用</title>
    <url>/2020/12/27/JS02/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>什么是对称加密</li>
<li>对称加密demo</li>
<li>什么是非对称加密</li>
<li>非对称加密demo</li>
<li>对称加密与非对称加密组合使用</li>
<li>介绍一套可行的混合加密方案，怎么应用到接口数据加密中</li>
<li>Demo源码工程</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="什么是对称加密"><a href="#什么是对称加密" class="headerlink" title="什么是对称加密"></a>什么是对称加密</h3><ul>
<li>定义：<blockquote>
<p>对称密钥算法（英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥</p>
</blockquote>
</li>
<li>优点：<blockquote>
<p>算法公开、计算量小、加密速度快、加密效率高，适合对大量数据进行加密的场景。 比如 HLS（HTTP Live Streaming）普通加密场景中，一般会使用 AES-128 对称加密算法对 TS 切片进行加密，以保证多媒体资源安全</p>
</blockquote>
</li>
<li><p>缺点：</p>
<blockquote>
<p>安全性不高，只要拿到秘钥就可以把数据解开</p>
</blockquote>
</li>
<li><p>对称加密的过程：</p>
<blockquote>
<p>发送方使用密钥将明文数据加密成密文，然后发送出去，接收方收到密文后，使用同一个密钥将密文解密成明文读取<br>  <img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/QQ%E5%9B%BE%E7%89%8720201227142444.png" alt=""></p>
</blockquote>
</li>
<li><p>个人理解：</p>
<blockquote>
<p>对称加密就好比一把锁的钥匙，一个密码箱存了东西，如果你有钥匙就可以把密码箱里面的宝贝取走</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="对称加密demo"><a href="#对称加密demo" class="headerlink" title="对称加密demo"></a>对称加密demo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.key &#x3D; CryptoJS.enc.Utf8.parse(&quot;0123456789abcdef&quot;);</span><br><span class="line">this.iv &#x3D; CryptoJS.enc.Utf8.parse(&quot;abcdef0123456789&quot;);</span><br><span class="line">&#x2F;**</span><br><span class="line">* AES 加密</span><br><span class="line">* @param iv</span><br><span class="line">* @param key</span><br><span class="line">* @param content 加密数据</span><br><span class="line">* @returns &#123;string&#125;</span><br><span class="line">* @private</span><br><span class="line">*&#x2F;</span><br><span class="line">__aesEncrypt(iv, key, content) &#123;</span><br><span class="line">    let text &#x3D; CryptoJS.enc.Utf8.parse(JSON.stringify(content));</span><br><span class="line">    let encrypted &#x3D; CryptoJS.AES.encrypt(text, key,</span><br><span class="line">        &#123;</span><br><span class="line">            iv: iv,</span><br><span class="line">            mode: CryptoJS.mode.CBC,</span><br><span class="line">            padding: CryptoJS.pad.Pkcs7,</span><br><span class="line">        &#125;);</span><br><span class="line">    return encrypted.toString();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* AES 解密</span><br><span class="line">* @param iv</span><br><span class="line">* @param key</span><br><span class="line">* @param content  解密数据</span><br><span class="line">* @returns &#123;string&#125;</span><br><span class="line">* @private</span><br><span class="line">*&#x2F;</span><br><span class="line">__aesDecrypt(iv, key, content) &#123;</span><br><span class="line">    let decrypt &#x3D; CryptoJS.AES.decrypt(content, key, &#123;</span><br><span class="line">        iv: iv,</span><br><span class="line">        mode: CryptoJS.mode.CBC,</span><br><span class="line">        padding: CryptoJS.pad.Pkcs7,</span><br><span class="line">    &#125;);</span><br><span class="line">    let decryptText &#x3D; decrypt.toString(CryptoJS.enc.Utf8);</span><br><span class="line">    return decryptText.replace(&#x2F;\&quot;&#x2F;g, &quot;&quot;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="什么是非对称加密"><a href="#什么是非对称加密" class="headerlink" title="什么是非对称加密"></a>什么是非对称加密</h3><ul>
<li><p>定义：</p>
<blockquote>
<p>非对称加密算法需要两个密钥：公开密钥（publickey：简称公钥）和私有密钥（privatekey：简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。 因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法</p>
</blockquote>
</li>
<li><p>优点：</p>
<blockquote>
<p>安全性更高，公钥是公开的，私钥是自己保存的，不需要将私钥提供给别人</p>
</blockquote>
</li>
<li><p>缺点</p>
<blockquote>
<p>加解密速度慢，只适合应对小数据加解密</p>
</blockquote>
</li>
<li><p>对称加密的过程：<br><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/QQ%E6%88%AA%E5%9B%BE20201227142658.png" alt=""></p>
</li>
</ul>
<ul>
<li><p>个人理解</p>
<blockquote>
<p>非对称加密：公钥就好比未锁的密码箱，只能存东西进去然后锁住。秘钥就好比密码箱的钥匙，可以打开秘密箱然后把里面的宝贝取走</p>
</blockquote>
</li>
<li><p>非对称加密demo</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.rsaEncryptor &#x3D; new JSEncrypt();</span><br><span class="line">this.rsaEncryptor.setPublicKey(this.rsa_pub_key);</span><br><span class="line">this.rsaDecryptor &#x3D; new JSEncrypt();</span><br><span class="line">this.rsaDecryptor.setPrivateKey(this.rsa_pri_key);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* RSA 加密</span><br><span class="line">* @param content</span><br><span class="line">* @returns &#123;CipherParams|PromiseLike&lt;ArrayBuffer&gt;&#125;</span><br><span class="line">* @private</span><br><span class="line">*&#x2F;</span><br><span class="line">__rsaEncrypt(content) &#123;</span><br><span class="line">    return this.rsaEncryptor.encrypt(content);</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;**</span><br><span class="line">* RSA 解密</span><br><span class="line">* @param content</span><br><span class="line">* @returns &#123;WordArray|PromiseLike&lt;ArrayBuffer&gt;&#125;</span><br><span class="line">* @private</span><br><span class="line">*&#x2F;</span><br><span class="line">__rsaDecrypt(content) &#123;</span><br><span class="line">    return this.rsaDecryptor.decrypt(content);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="对称加密与非对称加密组合使用"><a href="#对称加密与非对称加密组合使用" class="headerlink" title="对称加密与非对称加密组合使用"></a>对称加密与非对称加密组合使用</h3><blockquote>
<p>现在对称加密和非对称加密的缺点我们都知道了，那就结合对称加密和非对称加密的优点来个demo，思路：针对小数据对称加密的iv和key，采用非对称加密；针对大数据data采用对称加密。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 混合加密</span><br><span class="line">* @param iv</span><br><span class="line">* @param key</span><br><span class="line">* @param content</span><br><span class="line">* @returns &#123;&#123;data: string, iv: (CipherParams|PromiseLike&lt;ArrayBuffer&gt;), key: (CipherParams|PromiseLike&lt;ArrayBuffer&gt;)&#125;&#125;</span><br><span class="line">* @private</span><br><span class="line">*&#x2F;</span><br><span class="line">__hybirdEncrypt(iv, key, content) &#123;</span><br><span class="line">    const aesEncryptData &#x3D; this.__aesEncrypt(iv, key, content);</span><br><span class="line">    const rsaEncryptIv &#x3D; this.__rsaEncrypt(iv);</span><br><span class="line">    const rsaEncryptKey &#x3D; this.__rsaEncrypt(key);</span><br><span class="line">    return &#123;</span><br><span class="line">        iv: rsaEncryptIv,</span><br><span class="line">        key: rsaEncryptKey,</span><br><span class="line">        data: aesEncryptData,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 混合解密</span><br><span class="line">* @param encryptInfo</span><br><span class="line">* @returns &#123;string&#125;</span><br><span class="line">* @private</span><br><span class="line">*&#x2F;</span><br><span class="line">__hybirdDecrypt(encryptInfo) &#123;</span><br><span class="line">    const iv &#x3D; this.rsaDecryptor.decrypt(encryptInfo.iv);</span><br><span class="line">    const key &#x3D; this.rsaDecryptor.decrypt(encryptInfo.key);</span><br><span class="line">    const data &#x3D; encryptInfo.data;</span><br><span class="line">    return this.__aesDecrypt(iv, key, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="介绍一套可行混合加密方案，怎么应用到接口数据加密中。流程图如下："><a href="#介绍一套可行混合加密方案，怎么应用到接口数据加密中。流程图如下：" class="headerlink" title="介绍一套可行混合加密方案，怎么应用到接口数据加密中。流程图如下："></a>介绍一套可行混合加密方案，怎么应用到接口数据加密中。流程图如下：</h3><ul>
<li>思路如下：<ul>
<li>第1步：创建一套RSA 公私钥，公钥前端拿着，私钥服务端拿着</li>
<li>第2步：前端为每一个网络请求生成RequestID</li>
<li>第3步：客户端生成AES Key，然后将RequestID 作为Key,AES Key 作为Value 存内存</li>
<li>第4步：客户端用生成的AES Key 加密请求数据Request Data，用RSA公钥对AES Key进行加密，同时把requestID、加密数据、加密AES Key 发送给服务端</li>
<li>第5步：服务端用RSA私钥解密被加密的AES Key，然后再用解开的AES Key 对RequestData数据进行解密</li>
<li>第6步：服务端用AES Key对响应数据ResposneData加密+RequestID、返回给前端</li>
<li>第7步：前端根据服务端返回的RequestID 取出内存的AES key, 用AES key 解密Resposne Data数据，用完后删除内存RequestID 的AES key 数据。</li>
<li>最后：前端每次发送请求都创建AES Key 去加密数据，收到服务端响应数据解密用完后，就删除掉内存中的AES Key数据，如此循环就用一套RSA公私钥解决混合加密问题</li>
</ul>
</li>
<li>流程图：<br><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt=""></li>
</ul>
<hr>
<h3 id="Demo源码工程："><a href="#Demo源码工程：" class="headerlink" title="Demo源码工程："></a>Demo源码工程：</h3><ul>
<li>访问地址：<a href="https://github.com/aa4790139/encrypt_decrypt_sample">https://github.com/aa4790139/encrypt_decrypt_sample</a></li>
</ul>
<h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><blockquote>
<p>由于对称加密DES安全性已不太强，所以就选择了替代品AES。非常感谢阿宝哥提供的<a href="https://mp.weixin.qq.com/s/i_Clg5kmTBwcFoSUNO-naQ">玩转混合加密</a>文章，讲得通俗易懂，让我受益匪浅。最后阿宝哥提到把AES key 存放内存容易让他人搞到AES Key。所以我就去了解Web如何防调试、代<br>码怎么混淆等，下一篇：<a href="https://yanxuewen.cn/2020/12/27/Web01/">Web如何防调试</a></p>
</blockquote>
<hr>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/i_Clg5kmTBwcFoSUNO-naQ">阿宝哥-玩转混合加密</a></li>
</ul>
<hr>
<h3 id="更多相关资料："><a href="#更多相关资料：" class="headerlink" title="更多相关资料："></a>更多相关资料：</h3><ul>
<li><a href="https://www.jianshu.com/p/c44a8a1b7c38">DES加密算法原理</a></li>
<li><a href="https://www.cxyxiaowu.com/1478.html">算法科普：神秘的 DES 加密算法</a></li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>对称加密</tag>
        <tag>非对称加密</tag>
        <tag>AES</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>屏蔽：键盘按键、鼠标点击事件</title>
    <url>/2020/10/14/PreventEvent/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>屏蔽-键盘按键</li>
<li>屏蔽-鼠标点击</li>
<li>屏蔽-BackSpace</li>
</ul>
<a id="more"></a>
<h3 id="屏蔽-键盘按键"><a href="#屏蔽-键盘按键" class="headerlink" title="屏蔽-键盘按键"></a>屏蔽-键盘按键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加按键监听</span><br><span class="line">window.addEventListener(&#39;keydown&#39;, this.onKeyDown,true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除按键监听</span><br><span class="line">window.removeEventListener(&quot;keydown&quot;,this.onKeyDown,true);</span><br><span class="line"></span><br><span class="line">onKeyDown(val)&#123;</span><br><span class="line">    console.log(&#39;按下&#39; + val.key);</span><br><span class="line">    val.preventDefault();</span><br><span class="line">    val.stopPropagation();</span><br><span class="line">    val.cancelBubble &#x3D; true;</span><br><span class="line">    window.event.returnValue &#x3D; false;</span><br><span class="line">    window.event.preventDefault();</span><br><span class="line">    window.event.stopPropagation();</span><br><span class="line">    window.event.cancelBubble &#x3D; true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="屏蔽-鼠标点击"><a href="#屏蔽-鼠标点击" class="headerlink" title="屏蔽-鼠标点击"></a>屏蔽-鼠标点击</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加鼠标点击监听</span><br><span class="line">window.addEventListener(&#39;mousedown&#39;,this.onClick,true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除鼠标点击监听</span><br><span class="line">window.removeEventListener(&#39;mousedown&#39;,this.onClick,true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;which: 1-左键 2-中键 3-右键</span><br><span class="line">onClick(val)&#123;</span><br><span class="line">    console.error(&#39;点击&#39; + val.which);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="屏蔽-BackSpace"><a href="#屏蔽-BackSpace" class="headerlink" title="屏蔽-BackSpace"></a>屏蔽-BackSpace</h3><p>在IE页面跳转过程中，按BackSpace退格键默认返回上此浏览页，导致路由中断引起(Vue)页面卡死，所以需要在IE中屏蔽掉BackSpce退格键，但是在输入框中则不屏蔽。</p>
<ul>
<li>preventBackSpce.js： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const banBackSpace &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">  let ev &#x3D; e || window.event</span><br><span class="line">  &#x2F;&#x2F; 各种浏览器下获取事件对象</span><br><span class="line">  let obj &#x3D; ev.relatedTarget || ev.srcElement || ev.target || ev.currentTarget</span><br><span class="line">  &#x2F;&#x2F; 按下Backspace键</span><br><span class="line">  if (ev.keyCode &#x3D;&#x3D;&#x3D; 8) &#123;</span><br><span class="line">    &#x2F;&#x2F; 标签名称</span><br><span class="line">    let tagName &#x3D; obj.nodeName.toLowerCase();</span><br><span class="line">    &#x2F;&#x2F; 如果标签不是input或者textarea则阻止Backspace</span><br><span class="line">    if (tagName !&#x3D;&#x3D; &#39;input&#39; &amp;&amp; tagName !&#x3D;&#x3D; &#39;textarea&#39;) &#123;</span><br><span class="line">      return stopIt(ev)</span><br><span class="line">    &#125;</span><br><span class="line">    let tagType &#x3D; obj.type.toLowerCase() &#x2F;&#x2F; 标签类型</span><br><span class="line">    &#x2F;&#x2F; input标签除了下面几种类型，全部阻止Backspace</span><br><span class="line">    if (tagName &#x3D;&#x3D;&#x3D; &#39;input&#39; &amp;&amp; (tagType !&#x3D;&#x3D; &#39;text&#39; &amp;&amp; tagType !&#x3D;&#x3D; &#39;textarea&#39; &amp;&amp; tagType !&#x3D;&#x3D; &#39;password&#39;)) &#123;</span><br><span class="line">      return stopIt(ev)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; input或者textarea输入框如果不可编辑则阻止Backspace</span><br><span class="line">    if ((tagName &#x3D;&#x3D;&#x3D; &#39;input&#39; || tagName &#x3D;&#x3D;&#x3D; &#39;textarea&#39;) &amp;&amp; (obj.readOnly &#x3D;&#x3D;&#x3D; true || obj.disabled &#x3D;&#x3D;&#x3D; true)) &#123;</span><br><span class="line">      return stopIt(ev)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stopIt(ev) &#123;</span><br><span class="line">  if (ev.preventDefault) &#123;</span><br><span class="line">    &#x2F;&#x2F; preventDefault()方法阻止元素发生默认的行为</span><br><span class="line">    ev.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">  if (ev.returnValue) &#123;</span><br><span class="line">    &#x2F;&#x2F; IE浏览器下用window.event.returnValue &#x3D; false;实现阻止元素发生默认的行为</span><br><span class="line">  &#125;</span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 在需要使用的Vue页面引入组件(一般在main.vue中添加)</span><br><span class="line">import &#123;banBackSpace&#125; from &quot;@&#x2F;util&#x2F;preventBackspace&quot;;</span><br><span class="line"></span><br><span class="line">2. mounted 钩子函数挂载事件</span><br><span class="line">document.onkeypress &#x3D; banBackSpace;</span><br><span class="line">document.onkeydown &#x3D; banBackSpace;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>事件屏蔽</tag>
      </tags>
  </entry>
  <entry>
    <title>全栈学习-开篇-001</title>
    <url>/2020/09/29/LearningFullStack01/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>技术栈介绍</li>
<li>环境准备</li>
</ul>
<a id="more"></a>
<blockquote>
<p>起因：在网上搜索了挺久，都没找到让我很满意的项目学习，也买了好几个付费项目，看了一部分就会发现看不下去，发现很多问题，虽然说能学到一部分东西，但感觉这些项目只是为了快速赚钱搞的，项目结构不清晰、缺少项目相关的介绍文档、前后端项目代码不分离，代码也写的非常临时和随意等等，可能我要求过高了。我如果用这种方式去做一个正式商业化的项目，用这种态度搞出来的东西肯定做不大。说实话我以前做东西也很随意，但自从我读了《程序员修炼之道》这本书后(若想成为一名真正的程序员，一定要去好好阅读这边书，去吸收点灵气)，让我受益匪浅。要想成为一个好的工程师，就要约束好自己，做事情不要太随意，得有点工匠精神，像匠人一样打造自己的武器，一段时间后你会发现自己层次上了一个阶梯。为了提升下自己全栈方便的能力，选择了我慕客上购买的一个小项目，这个小项目很适合入手，所以就拿这个项目(简版-慕客商城)开启全栈学习之旅。</p>
</blockquote>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ol>
<li><p>前端</p>
<ul>
<li>Vue - 2.2.6</li>
<li>vue-cookie - 1.1.4</li>
<li>vue-resource - 1.3.1</li>
<li>vue-router - 2.3.1</li>
<li>vuex - 2.3.1</li>
</ul>
</li>
<li><p>后端</p>
<ul>
<li>Node.js - 12.13.1</li>
<li>Express - 4.14.1</li>
<li>Mongoose - 5.0.1</li>
<li>Mongodb - 4.2.8</li>
</ul>
</li>
</ol>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>WebStorm - 2020.1 (方便后端调试，对比VScode、SublimeText、HBuildX 这IDE功能更强大)</li>
<li>XShell6 、XFTP6 </li>
<li>Navicat Premium 12 (低版本不支持连mongodb，所以请选择高一点的版本)</li>
</ul>
<blockquote>
<p>未完待续…</p>
</blockquote>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>全栈</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-01：Python与C# 基本语法区别</title>
    <url>/2020/10/31/Python01/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>Python 与 C# 基本语法区别</li>
<li>具体语法示例</li>
</ul>
<a id="more"></a>
<h3 id="最明显的区别"><a href="#最明显的区别" class="headerlink" title="最明显的区别"></a>最明显的区别</h3><ol>
<li>Python if、for、while等 包裹代码块不是用{}，而是使用”:”和 换行缩进</li>
<li>Python 弱类型语言，同时每句话结束后无需加分号”;”，与JAVAScript 类似</li>
</ol>
<h3 id="具体语法区别："><a href="#具体语法区别：" class="headerlink" title="具体语法区别："></a>具体语法区别：</h3><ul>
<li>if<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#：</span><br><span class="line">if(条件)&#123;</span><br><span class="line">    print(&quot;xxx&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Python:</span><br><span class="line">if 条件:</span><br><span class="line">    print(&quot;xxx&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>for<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#:</span><br><span class="line">var list &#x3D; new List&lt;int&gt;()&#123;1, 2, 3&#125;;</span><br><span class="line">foreach(n : list)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Python:</span><br><span class="line">list &#x3D; &#123;1, 2, 3&#125;</span><br><span class="line">for n in list:</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure></li>
<li>强制类型转换<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C# </span><br><span class="line">var num &#x3D; &quot;12&quot;;</span><br><span class="line">int n &#x3D; (int)num</span><br><span class="line"></span><br><span class="line">Python</span><br><span class="line">num &#x3D; &quot;12&quot;</span><br><span class="line">n &#x3D; int(num)</span><br></pre></td></tr></table></figure></li>
<li><p>数组切片： 其实就是copy出数组中的指定区域元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listnames &#x3D; [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]</span><br><span class="line">listnames[start_index:end_index] </span><br><span class="line">(注意：copy出来的集合为[start_index,end_index)之前的元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数及注释说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#：</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 测试函数</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public string test(string username)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;hello &quot; + username);</span><br><span class="line">    return username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Python:</span><br><span class="line">def test(username):</span><br><span class="line">    &quot;&quot;&quot;测试函数&quot;&quot;&quot;</span><br><span class="line">    print(&quot;hello &quot; + username)</span><br><span class="line">    return username.title()</span><br></pre></td></tr></table></figure></li>
<li><p>传递任意数量的实参：*实参名 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#：无对应语法</span><br><span class="line"></span><br><span class="line">Python</span><br><span class="line">def make_pizza(*toppings): </span><br><span class="line">    &quot;&quot;&quot;打印顾客点的所有配料&quot;&quot;&quot; </span><br><span class="line">    print(toppings)</span><br><span class="line"></span><br><span class="line"># 任意数量实参, 如果是键值对，请使用**双星号，比如：</span><br><span class="line">def build_profile(first,last,**user_info):</span><br><span class="line">    for key, value in user_info.items(): </span><br><span class="line">        print(&quot;key&#x3D;&quot; + key + &quot;value&#x3D;&quot; + value)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：任意数量实参只能有一个，并且只能放在函数最后一个参数的位置</p>
</blockquote>
</li>
<li><p>模块导入：类似java 在一个类文件中，导入另外一个文件类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#: 使用userspace 引入空间，既可以直接使用空间中的类</span><br><span class="line">one.cs：内容如下</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">namespace onens </span><br><span class="line">&#123;</span><br><span class="line">    public class One</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">two.cs：内容如下</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">using onens</span><br><span class="line">namespace twons</span><br><span class="line">&#123;</span><br><span class="line">    public class Two</span><br><span class="line">    &#123;</span><br><span class="line">        public Two()</span><br><span class="line">        &#123;</span><br><span class="line">            var one &#x3D; new One()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Python: 导出模块后，就可以通过模块名称访问其中的所有方法</span><br><span class="line">OneModule.py：内容如下</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">def one(name, address):</span><br><span class="line">    print(name + &quot;&quot; + address)</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">TwoModule.py：内容如下</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">import OneModule</span><br><span class="line">def two():</span><br><span class="line">    OneModule.one(&quot;potter&quot;,&quot;sz&quot;)</span><br><span class="line">-------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入特定函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#: 没有导出特定函数一说，只有using namespace的内容 或者说import dll中的方法，比如：</span><br><span class="line">[DllImport(&quot;User32.DLL&quot;)]</span><br><span class="line">public static extern IntPtr GetActiveWindow();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python：</span><br><span class="line">from module_name import function_name1，function_name2...</span><br><span class="line"># 使用as给导入函数取别名</span><br><span class="line">from module_name import fuction_name as fn</span><br><span class="line"># 使用as给导入模块取别名</span><br><span class="line">import module_name as mn</span><br><span class="line"># 使用*号，导入模块所有函数</span><br><span class="line">from module_name import *</span><br></pre></td></tr></table></figure></li>
<li>类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造方法</span><br><span class="line">C#: </span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    public Test(string name,string address)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Python: __init__ 就是构造方法, self是自动传递的</span><br><span class="line">class Test():</span><br><span class="line">    def __init__(self, name, address):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.address &#x3D; address</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;hello&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>继承<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#：</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">    private string make;</span><br><span class="line">    private string model;</span><br><span class="line">    private string year;</span><br><span class="line">    public Car(string make, string model, string year)</span><br><span class="line">    &#123;</span><br><span class="line">        this.make &#x3D; make;</span><br><span class="line">        this.model &#x3D; model;</span><br><span class="line">        this.year &#x3D; year;</span><br><span class="line">    &#125;</span><br><span class="line">    public virtual void Run() </span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">class ElectricCar : Car</span><br><span class="line">&#123;</span><br><span class="line">    private string makeAddress;</span><br><span class="line">    public ElectricCar(string makeAddress, string make, string model ,string year) : base(make, model,year)</span><br><span class="line">    &#123;</span><br><span class="line">        this.makeAddress &#x3D; makeAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    public override void Run()</span><br><span class="line">    &#123;</span><br><span class="line">        base.Run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Python:</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">class Car():</span><br><span class="line">    def __init__(self,make,model,year):</span><br><span class="line">        self.make &#x3D; make</span><br><span class="line">        self.model &#x3D; model</span><br><span class="line">        self.year &#x3D; year</span><br><span class="line">    def run():</span><br><span class="line">        print(&quot;run&quot;)</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">class ElectricCar(Car):</span><br><span class="line">    def __init__(self,make,model,year):</span><br><span class="line">        super().__init__(make,model,year)</span><br><span class="line">    def run()</span><br><span class="line">        ***子类重写父类方法，同名即可***</span><br><span class="line">        print(&quot;ElectricCar run&quot;)</span><br><span class="line">-------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li>
<li>导入类：(格式：from module_name import class,class)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from car import Car</span><br><span class="line">my_new_car &#x3D; Car(&#39;audi&#39;, &#39;a4&#39;, 2016)</span><br></pre></td></tr></table></figure></li>
<li>文件读写<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#: </span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">1. 读取整个文件</span><br><span class="line">using (FileStream fs &#x3D; File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))</span><br><span class="line">&#123;</span><br><span class="line">    StreamReader sr &#x3D; new StreamReader(fs);</span><br><span class="line">    strContent &#x3D; sr.ReadToEnd();</span><br><span class="line">    sr.Close();</span><br><span class="line">    fs.Close();</span><br><span class="line">&#125;</span><br><span class="line">2. 逐行读取文件</span><br><span class="line">using (StreamReader sr &#x3D; new StreamReader(filepath))</span><br><span class="line">&#123;</span><br><span class="line">    String line;</span><br><span class="line">    while((line&#x3D;sr.ReadLine())!&#x3D;null)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3. 写入文件</span><br><span class="line">using (FileStream fs &#x3D; File.Open(filepath, FileMode.Create, FileAccess.Write, FileShare.ReadWrite))</span><br><span class="line">&#123;</span><br><span class="line">    StreamWriter sw &#x3D; new StreamWriter(fs);</span><br><span class="line">    sw.WriteLine(content);</span><br><span class="line">    sw.Flush();</span><br><span class="line">    sw.Close();</span><br><span class="line">    fs.Close();</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Python:</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">1.读取整个文件，使用rstrip过滤掉前后空格</span><br><span class="line">with open(&#39;pi_digits.txt&#39;) as file_object: </span><br><span class="line">    contents &#x3D; file_object.read() </span><br><span class="line">    print(contents.rstrip())</span><br><span class="line">2. 逐行读取文件</span><br><span class="line">with open(&#39;pi_digits.txt&#39;) as file_object: </span><br><span class="line">    for line in file_object: </span><br><span class="line">    print(line.rstrip())</span><br><span class="line">3. 写入文件：&#39;w&#39;、&#39;r&#39;、&#39;a&#39; 分别代表&#39;写&#39;、&#39;读&#39;、&#39;追加&#39;</span><br><span class="line">filename &#x3D; &#39;programming.txt&#39; </span><br><span class="line">with open(filename, &#39;w&#39;) as file_object: </span><br><span class="line">    file_object.write(&quot;I love programming.&quot;)</span><br></pre></td></tr></table></figure></li>
<li>存取数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#：其实就是文件写和读</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Python: </span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">1. 存：</span><br><span class="line">import json </span><br><span class="line">numbers &#x3D; [2, 3, 5, 7, 11, 13]</span><br><span class="line">with open(filename, &#39;w&#39;) as f_obj: </span><br><span class="line">    json.dump(numbers, f_obj)</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">2. 取</span><br><span class="line">import json </span><br><span class="line">with open(filename, &#39;r&#39;) as f_obj:</span><br><span class="line">    print(json.load(f_obj))</span><br><span class="line">-------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li>
<li>异常<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#：</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">int r &#x3D; 0;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    r &#x3D; 5&#x2F;0</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;出现异常&quot;);</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;try最后执行代码&quot;);</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Python：</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">try:</span><br><span class="line">    r &#x3D; 5&#x2F;0</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    raise Exception(&quot;抛出异常：除数不能为0&quot;)</span><br><span class="line">except FileNotFoundError:</span><br><span class="line">    print(&quot;异常打印：文件找不到&quot;)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;其他异常&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无异常，打印此句&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print(&quot;最后打印此句&quot;)</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">1. else 缩进后代码，相当于把这部分代码放到try-except中或者取消缩进放到最后一样，没啥特别的</span><br><span class="line">2. except 不带具体异常，就相当于C#的catch(Exception)</span><br><span class="line">3. raise 相当于C#的throw</span><br><span class="line">-------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li>
<li>lambda<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C#：</span><br><span class="line">格式：(arguments) &#x3D;&gt; &#123; expression &#125;;</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Func&lt;int, int&gt; func &#x3D; (x) &#x3D;&gt; &#123; return x + 5; &#125;;</span><br><span class="line">Console.WriteLine(&quot;&quot; + func(5));</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Python:</span><br><span class="line">格式：lambda arguments : expression</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">func &#x3D; lambda a : a + 10</span><br><span class="line">print(func(5))</span><br><span class="line">-------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li>
<li>API <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python: (注意：使用前请使用pip install requests 安装requests模块)</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;search&#x2F;repositories?q&#x3D;language:python&amp;sort&#x3D;stars&#39;</span><br><span class="line">response &#x3D; requests.get(url)</span><br><span class="line">print(&quot;Status code:&quot;, response.status_code)</span><br><span class="line"># 将API响应存储在一个变量中</span><br><span class="line">response_dict &#x3D; response.json()</span><br><span class="line">print(&quot;Total repositories:&quot;, response_dict[&#39;total_count&#39;])</span><br><span class="line"># 用完记得关闭，否则下次运行会报：远程主机强迫关闭了一个现有的连接</span><br><span class="line">response.close()</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>UniApp 如何引入Iconfont阿里巴巴矢量图标库</title>
    <url>/2020/11/13/UniApp01/</url>
    <content><![CDATA[<h3 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下:"></a>步骤如下:</h3><ol>
<li>下载图标项目, 解压后效果如下<br><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/20201113164039.png" alt=""></li>
<li><p>修改iconfont.css文件</p>
<p> 修改前格式：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;font-family: &quot;iconfont&quot;;</span><br><span class="line">src: url(&#39;iconfont.eot?t&#x3D;1605254910083&#39;); &#x2F;* IE9 *&#x2F;</span><br><span class="line">src: url(&#39;iconfont.eot?t&#x3D;1605254910083#iefix&#39;) format(&#39;embedded-opentype&#39;), &#x2F;* IE6-IE8 *&#x2F;</span><br><span class="line">url(&#39;data:application&#x2F;x-font-woff2;charset&#x3D;utf-8;base64,转换的base64内容&#39;) format(&#39;woff2&#39;),</span><br><span class="line">url(&#39;iconfont.woff?t&#x3D;1605254910083&#39;) format(&#39;woff&#39;),</span><br><span class="line">url(&#39;iconfont.ttf?t&#x3D;1605254910083&#39;) format(&#39;truetype&#39;), &#x2F;* chrome, firefox, opera, Safari, Android, iOS 4.2+ *&#x2F;</span><br><span class="line">url(&#39;iconfont.svg?t&#x3D;1605254910083#iconfont&#39;) format(&#39;svg&#39;); &#x2F;* iOS 4.1- *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 修改后格式: </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    font-family: &quot;iconfont&quot;;</span><br><span class="line">    src: url(&#39;data:application&#x2F;x-font-woff2;charset&#x3D;utf-8;base64,转换的base64内容&#39;) format(&#39;woff2&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Copy字体文件iconfont.ttf和样式文件iconfont.css 至UniApp项目static/font目录中</li>
</ol>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>UniApp</tag>
      </tags>
  </entry>
  <entry>
    <title>Web代码混淆</title>
    <url>/2020/12/29/Web02/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>代码混淆</li>
<li>环境准备</li>
<li>如何配置UglifyJsPlugin混淆参数</li>
<li>混淆效果</li>
<li>Demo源码工程</li>
</ul>
<a id="more"></a>
<h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><ul>
<li><p>定义：代码混淆(Obfuscated code)亦称花指令，是将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式的行为。通俗一点讲就是你写的代码，通过混淆工具，把你的源代码混淆得别人看不太懂。</p>
</li>
<li><p>起因：由于Web可以用浏览器调试工具，直接查看到我们的源代码，如果我们的源代码中包含了敏感信息(比如：加密密钥、服务器内部接口地址等)，那么对于不怀好意的人，就可能拿着这些东西攻击我们的服务器，所以我们需要把我们的代码去掉注释、混淆代码等，这样别人就没那么容易看懂我们的代码了，提高服务被攻击的门槛。</p>
</li>
</ul>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><blockquote>
<p>由于我尝试使用WebPack3.x的版本，利用UglifyJsPlugin版本来混淆打包，发现各种配置问题，然后导致打包出问题，所以推荐WebPack4.x 以上版本。我的环境如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies&quot;: &#123;</span><br><span class="line">		&quot;vue&quot;: &quot;^2.6.11&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel&#x2F;cli&quot;: &quot;^7.8.4&quot;,</span><br><span class="line">    &quot;@babel&#x2F;core&quot;: &quot;^7.8.7&quot;,</span><br><span class="line">    &quot;@babel&#x2F;preset-env&quot;: &quot;^7.8.7&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^8.0.6&quot;,</span><br><span class="line">    &quot;clean-webpack-plugin&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;css-loader&quot;: &quot;^3.4.2&quot;,</span><br><span class="line">    &quot;html-loader&quot;: &quot;^1.3.2&quot;,</span><br><span class="line">    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;uglifyjs-webpack-plugin&quot;: &quot;^2.2.0&quot;,</span><br><span class="line">    &quot;url-loader&quot;: &quot;^4.1.1&quot;,</span><br><span class="line">    &quot;vue-loader&quot;: &quot;^15.9.0&quot;,</span><br><span class="line">    &quot;vue-style-loader&quot;: &quot;^4.1.2&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.42.0&quot;,</span><br><span class="line">    &quot;webpack-bundle-analyzer&quot;: &quot;^4.3.0&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.11&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^3.10.3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何配置UglifyJsPlugin混淆参数"><a href="#如何配置UglifyJsPlugin混淆参数" class="headerlink" title="如何配置UglifyJsPlugin混淆参数"></a>如何配置UglifyJsPlugin混淆参数</h3><blockquote>
<p>由于混淆需指定混淆哪些代码，不能把JS提供的API、第三方库的API相关的代码也给混淆掉，所以需要在写代码时一定要养成养好的编码规范，这样在配置混淆正在表达式时就非常好些了。以下介绍我的2种命令规范，所以下面的混淆正则表达式就非常好写。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m_xxx : 成员变量</span><br><span class="line">__function : 方法名</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new UglifyJsPlugin(</span><br><span class="line">&#123;</span><br><span class="line">    uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">            &#x2F;&#x2F; warnings: false,</span><br><span class="line">            &#x2F;* 移除没被引用的代码 *&#x2F;</span><br><span class="line">            dead_code: true,</span><br><span class="line">            &#x2F;* 当 Function(args, code)的args 和 code都是字符串时，压缩并混淆 *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; unsafe_Func: true,</span><br><span class="line">            &#x2F;* 干掉没有被引用的函数和变量 *&#x2F;</span><br><span class="line">            unused: true,</span><br><span class="line">            &#x2F;* 干掉顶层作用域中没有被引用的函数或变量 *&#x2F;</span><br><span class="line">            toplevel: true,</span><br><span class="line">            &#x2F;* 干掉console.*函数 *&#x2F;</span><br><span class="line">            drop_console: true,</span><br><span class="line">            &#x2F;* 干掉Debugger*&#x2F;</span><br><span class="line">            drop_debugger: true,</span><br><span class="line">            &#x2F;* 压缩代码次数 注意：数字越大压缩耗时越长 *&#x2F;</span><br><span class="line">            passes: 1,</span><br><span class="line">            &#x2F;* 传true以防止压缩时把1&#x2F;0转成Infinity，那可能会在chrome上有性能问题 *&#x2F;</span><br><span class="line">            keep_infinity: true</span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">            comments: false,</span><br><span class="line">        &#125;,</span><br><span class="line">        mangle: &#123;</span><br><span class="line">            properties: &#123;</span><br><span class="line">                &#x2F;&#x2F; keep_fnames: false,</span><br><span class="line">                &#x2F;* 说明：混淆正在表达式就非常好写 *&#x2F;</span><br><span class="line">                regex: &#x2F;(^__|^m_)\w+&#x2F;,</span><br><span class="line">                reserved: [&quot;$&quot;, &quot;iv&quot;, &quot;mode&quot;, &quot;padding&quot;, &quot;CryptoJS&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    cache: true,</span><br><span class="line">    extractComments: false,</span><br><span class="line">    sourceMap: false,</span><br><span class="line">    parallel: true</span><br><span class="line">&#125;</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<h3 id="混淆效果"><a href="#混淆效果" class="headerlink" title="混淆效果"></a>混淆效果</h3><p><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master/img/20201229141408.png" alt=""></p>
<h3 id="Demo源码工程"><a href="#Demo源码工程" class="headerlink" title="Demo源码工程"></a>Demo源码工程</h3><ul>
<li>访问地址：<a href="https://github.com/aa4790139/webpack4_confuse_demo">https://github.com/aa4790139/webpack4_confuse_demo</a></li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.freebuf.com/articles/web/102269.html">可信前端之路：代码保护</a></li>
<li><a href="https://webpack.docschina.org/plugins/uglifyjs-webpack-plugin/">UglifyjsWebpackPlugin 使用说明</a></li>
<li><a href="https://github.com/LiPinghai/UglifyJSDocCN/blob/master/README.md#compress-options">UglifyJSDocCN</a></li>
<li><a href="http://lisperator.net/uglifyjs/transform">UglifyJS</a></li>
<li><a href="https://segmentfault.com/a/1190000008995453">UglifyJS中文文档</a></li>
<li><a href="https://github.com/yacan8/blog/blob/master/posts/JavaScript%E6%B7%B7%E6%B7%86%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA.md">JavaScript混淆安全加固</a></li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>混淆</tag>
        <tag>UglifyJS</tag>
      </tags>
  </entry>
  <entry>
    <title>Web如何防调试</title>
    <url>/2020/12/27/Web01/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>常用防调试方法</li>
<li>引入条件编译打包</li>
</ul>
<a id="more"></a>
<hr>
<h3 id="常用防调试方法"><a href="#常用防调试方法" class="headerlink" title="常用防调试方法"></a>常用防调试方法</h3><ul>
<li>屏蔽：相关按键 + 鼠标右键</li>
<li>检测控制台是否打开</li>
<li>检测DevTools 是否打开</li>
<li>工具类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;*************************************************************************</span><br><span class="line">&#x2F;&#x2F;     创建日期:     2020-12-23 04:12:52</span><br><span class="line">&#x2F;&#x2F;     文件名称:     AntiDebugUtil.js</span><br><span class="line">&#x2F;&#x2F;     创建作者:     Harry</span><br><span class="line">&#x2F;&#x2F;     版权所有:     剑齿虎</span><br><span class="line">&#x2F;&#x2F;     开发版本:     V1.0</span><br><span class="line">&#x2F;&#x2F;     相关说明:     反调试程序</span><br><span class="line">&#x2F;&#x2F;*************************************************************************</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------------------------------------------------------------------------</span><br><span class="line">function AntiDebugUtils() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------------------------------------------------------------------------</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 监听按键 + 鼠标右键</span><br><span class="line"> * *&#x2F;</span><br><span class="line">AntiDebugUtils.prototype.registerKeyDown &#x3D; function () &#123;</span><br><span class="line">  console.log(&quot;hook-----&gt;registerKeyDown&quot;);</span><br><span class="line">  &#x2F;*监听F12、Ctrl + Shift + I、Ctrl + S*&#x2F;</span><br><span class="line">  document.onkeydown &#x3D; function (event) &#123;</span><br><span class="line">    if (event.key &#x3D;&#x3D;&#x3D; &quot;F12&quot;) &#123;</span><br><span class="line">      console.log(&quot;KeyDown: F12&quot;);</span><br><span class="line">      event.returnValue &#x3D; false;</span><br><span class="line">    &#125; else if (event.ctrlKey &amp;&amp; event.shiftKey &amp;&amp; event.key &#x3D;&#x3D;&#x3D; &quot;I&quot;) &#123;&#x2F;&#x2F;此处I必须大写</span><br><span class="line">      console.log(&quot;KeyDown: Ctrl + Shift + I&quot;);</span><br><span class="line">      event.returnValue &#x3D; false;</span><br><span class="line">    &#125; else if (event.ctrlKey &amp;&amp; event.key &#x3D;&#x3D;&#x3D; &quot;s&quot;) &#123;&#x2F;&#x2F;此处s必须小写</span><br><span class="line">      console.log(&quot;KeyDown: Ctrl + S&quot;);</span><br><span class="line">      event.returnValue &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">* 监听右键菜单</span><br><span class="line">* *&#x2F;</span><br><span class="line">  document.oncontextmenu &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&quot;KeyDown: 鼠标右键&quot;);</span><br><span class="line">    event.returnValue &#x3D; false;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;-------------------------------------------------------------------------</span><br><span class="line">&#x2F;*</span><br><span class="line">* 检测控制台是否打开</span><br><span class="line">* *&#x2F;</span><br><span class="line">AntiDebugUtils.prototype.registerConsoleWindow &#x3D; function () &#123;</span><br><span class="line">  console.log(&quot;hook-----&gt;registerConsoleWindow&quot;);</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    const before &#x3D; new Date();</span><br><span class="line">    (function () &#123;</span><br><span class="line">    &#125;).constructor(&quot;debugger&quot;)();</span><br><span class="line">    &#x2F;&#x2F; debugger;</span><br><span class="line">    const after &#x3D; new Date();</span><br><span class="line">    const cost &#x3D; after.getTime() - before.getTime();</span><br><span class="line">    if (cost &gt; 100) &#123;</span><br><span class="line">      console.log(&quot;registerConsoleWindow: 检测到打开了调试窗口&quot;);</span><br><span class="line">      window.location &#x3D; &quot;about:blank&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;-------------------------------------------------------------------------</span><br><span class="line">&#x2F;*</span><br><span class="line">* 检测DevTools 是否打开</span><br><span class="line">* *&#x2F;</span><br><span class="line">AntiDebugUtils.prototype.registerDevTools &#x3D; function () &#123;</span><br><span class="line">  console.log(&quot;hook-----&gt;registerDevTools&quot;);</span><br><span class="line">  let div &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">  let loop &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(div);</span><br><span class="line">    console.clear();</span><br><span class="line">  &#125;);</span><br><span class="line">  Object.defineProperty(div, &quot;id&quot;, &#123;</span><br><span class="line">    get: () &#x3D;&gt; &#123;</span><br><span class="line">      clearInterval(loop);</span><br><span class="line">      window.location &#x3D; &quot;about:blank&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;-------------------------------------------------------------------------</span><br><span class="line">AntiDebugUtils.prototype.hook &#x3D; function () &#123;</span><br><span class="line">  console.log(&quot;hook-----&gt;&quot;);</span><br><span class="line">  &#x2F;&#x2F; this.registerKeyDown();</span><br><span class="line">  &#x2F;&#x2F; this.registerConsoleWindow();</span><br><span class="line">  &#x2F;&#x2F; this.registerDevTools();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;-------------------------------------------------------------------------</span><br><span class="line">const antiDebugUtils &#x3D; new AntiDebugUtils();</span><br><span class="line">export default antiDebugUtils;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用方法：main.js 引入和挂在即可<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* IFTRUE_isRelease *&#x2F;</span><br><span class="line">import antiDebugUtils from &quot;.&#x2F;utls&#x2F;AntiDebugUtil&quot;;</span><br><span class="line">antiDebugUtils.hook();</span><br><span class="line">&#x2F;*FITRUE_isRelease *&#x2F;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="引入条件编译打包："><a href="#引入条件编译打包：" class="headerlink" title="引入条件编译打包："></a>引入条件编译打包：</h3><blockquote>
<p>项目随着需求不断迭代开发，无法避免的会出现各种环境、各种渠道等，然后针对其打出不同的包，所以就需要我们去了解下条件编译，针对不同条件把不符合条件的代码(JS\CSS\HTML)排除，条件编译插件很多，推荐js-conditional-compile-loader插件，我针对JS\CSS\HTML 分别进行条件编译测试都通过，简单好用</p>
</blockquote>
<ul>
<li>配置条件变量：修改webpack.base.conf.js中的配置(提示：如果使用不同版本Webpack，可能没有webpack.base.conf.js，那么找对应的webpack配置文件即可)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据自己的喜好在options中添加条件变量</span><br><span class="line">const conditionalCompiler &#x3D; &#123;</span><br><span class="line">  loader: &#39;js-conditional-compile-loader&#39;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    isBeta: (process.env.ENV_CONFIG !&#x3D;&#x3D; &quot;prod&quot;) ? true : false,</span><br><span class="line">    isRelease: (process.env.ENV_CONFIG &#x3D;&#x3D;&#x3D; &quot;prod&quot;) ? true : false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 找到module.exports中的module.rules, 修改成如下样子</span><br><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">    use: [&#39;vue-loader&#39;, conditionalCompiler],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">test: &#x2F;\.js$&#x2F;,</span><br><span class="line">include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)],</span><br><span class="line">use: [</span><br><span class="line">    &#x2F;&#x2F;step-2</span><br><span class="line">    &#39;babel-loader?cacheDirectory&#39;,</span><br><span class="line">    &#x2F;&#x2F;step-1</span><br><span class="line">    conditionalCompiler,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>使用方法：</p>
<blockquote>
<p>/<em> IFTRUE_条件变量 </em>/  you need contorl coding..  /<em>FITRUE_条件变量 </em>/</p>
</blockquote>
</li>
<li><p>示例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* IFTRUE_isRelease *&#x2F;</span><br><span class="line">import antiDebugUtils from &quot;.&#x2F;utls&#x2F;AntiDebugUtil&quot;;</span><br><span class="line">antiDebugUtils.hook();</span><br><span class="line">&#x2F;*FITRUE_isRelease *&#x2F;</span><br></pre></td></tr></table></figure>
<ul>
<li>更多：<blockquote>
<p>其实上面的一种方法就够我用了，你如需了解更多用法请查看API <a href="https://github.com/hzsrc/js-conditional-compile-loader/blob/master/readme-cn.md">传输门</a></p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><blockquote>
<p>现在我们知道怎么防调试了，那接下来怎么做到更安全，那就是把代码混淆掉。下一篇：<a href="">Web代码混淆</a></p>
</blockquote>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul>
<li><a href="https://www.zhangbj.com/p/585.html">Web防调试方法</a></li>
<li><a href="https://github.com/hzsrc/js-conditional-compile-loader/blob/master/readme-cn.md">js-conditional-compile-loader 使用教程</a></li>
</ul>
<h3 id="更多相关："><a href="#更多相关：" class="headerlink" title="更多相关："></a>更多相关：</h3><ul>
<li>[conditional-compile-loader]<a href="https://developer.aliyun.com/mirror/npm/package/conditional-compile-loader">https://developer.aliyun.com/mirror/npm/package/conditional-compile-loader</a></li>
<li><a href="https://flands.com/2018/11/06/29.%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/#package-json">webpack Vue条件编译</a></li>
<li><a href="https://zoumiaojiang.com/article/common-web-security/">常见 Web 安全攻防总结</a></li>
<li><a href="https://www.zhangbj.com/p/586.html">攻破Web防调试方法</a></li>
</ul>
<hr>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>防调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Web构建优化</title>
    <url>/2020/12/30/WebBuild01/</url>
    <content><![CDATA[<h3 id="概要内容"><a href="#概要内容" class="headerlink" title="概要内容"></a>概要内容</h3><ul>
<li>DllPlugin 和 DllReferencePlugin 简介</li>
<li>如何使用DllPlugin打包，及DllReferencePlugin如何引用dll</li>
<li>构建优化效果</li>
<li>SplitChunks </li>
<li>Demo源码工程</li>
</ul>
<a id="more"></a>
<hr>
<h3 id="DllPlugin-和-DllReferencePlugin-简介"><a href="#DllPlugin-和-DllReferencePlugin-简介" class="headerlink" title="DllPlugin 和 DllReferencePlugin 简介"></a>DllPlugin 和 DllReferencePlugin 简介</h3><ul>
<li>DllPlugin: <blockquote>
<p>这个插件是在一个额外的独立的 webpack 设置中创建一个只有 dll 的 bundle(dll-only-bundle)。 这个插件会生成一个名为 manifest.json 的文件，这个文件是用来让 DLLReferencePlugin 映射到相关的依赖上去的。</p>
</blockquote>
</li>
<li>DllReferencePlugin:<blockquote>
<p>此插件配置在 webpack 的主配置文件中，此插件会把 dll-only-bundles 引用到需要的预编译的依赖中</p>
</blockquote>
</li>
<li>通俗点讲：<blockquote>
<p>DllPlugin 插件负责把第三方公共库，打包进一个独立的dll库中。最后项目打包时DllReferencePlugin 通过manifest.json 来引用dll的公共库，避免项目每次构建时都将第三库和业务代码进行重复打包。</p>
</blockquote>
</li>
<li>优点：<ul>
<li>提升打包构建速度</li>
<li>避免掉重复下载公共库js</li>
</ul>
</li>
</ul>
<h3 id="如何使用DllPlugin打包，及DllReferencePlugin如何引用dll"><a href="#如何使用DllPlugin打包，及DllReferencePlugin如何引用dll" class="headerlink" title="如何使用DllPlugin打包，及DllReferencePlugin如何引用dll"></a>如何使用DllPlugin打包，及DllReferencePlugin如何引用dll</h3><ul>
<li>DllPlugin 配置需要打包第三方库至dll中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;webpack.dll.config.js</span><br><span class="line"></span><br><span class="line">const DllPlugin &#x3D; require(&#39;webpack&#x2F;lib&#x2F;DllPlugin&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">var packageJsonContent &#x3D; fs.readFileSync(path.resolve(__dirname, &#39;..&#x2F;package.json&#39;));</span><br><span class="line">var packageJson &#x3D; JSON.parse(packageJsonContent);</span><br><span class="line"></span><br><span class="line">var dependencies &#x3D; Object.keys(packageJson.dependencies);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        vendor: dependencies</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#39;..&#x2F;dist&#39;),</span><br><span class="line">        filename: &#39;vendor.bundle.js&#39;,</span><br><span class="line">        library: &#39;vendor_lib&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new DllPlugin(&#123;</span><br><span class="line">            context: __dirname,</span><br><span class="line">            name: &#39;vendor_lib&#39;,</span><br><span class="line">            &#x2F;* 生成manifest文件输出的位置和文件名称 *&#x2F;</span><br><span class="line">            path: path.resolve(__dirname, &#39;..&#x2F;dist&#x2F;vendor-manifest.json&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>DllReferencePlugin如何引用dll</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;webpack.config.js 中 plugins添加以下代码</span><br><span class="line"></span><br><span class="line">new DllReferencePlugin(&#123;</span><br><span class="line">            manifest: require(path.resolve(__dirname, &#39;..&#x2F;dist&#x2F;vendor-manifest.json&#39;))</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<h3 id="构建优化效果"><a href="#构建优化效果" class="headerlink" title="构建优化效果"></a>构建优化效果</h3><p><img data-src="https://cdn.jsdelivr.net/gh/aa4790139/BlogPicBed@master//img/20201230131323.png" alt=""></p>
<h3 id="SplitChunks"><a href="#SplitChunks" class="headerlink" title="SplitChunks"></a>SplitChunks</h3><ul>
<li>简介：Webpack中一个提取或分离代码的插件，主要作用是提取公共代码，防止代码被重复打包，拆分过大的js文件，合并零散的js文件，可配置</li>
<li>配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;webpack.dll.config.js中optimization 中新增如下配置</span><br><span class="line">splitChunks: &#123;</span><br><span class="line">            chunks: &quot;async&quot;,</span><br><span class="line">            minSize: 30000,</span><br><span class="line">            minChunks: 1,</span><br><span class="line">            maxAsyncRequests: 5,</span><br><span class="line">            maxInitialRequests: 3,</span><br><span class="line">            automaticNameDelimiter: &#39;~&#39;,</span><br><span class="line">            name: true,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                vendors: &#123;</span><br><span class="line">                    test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]&#x2F;,</span><br><span class="line">                    priority: -10</span><br><span class="line">                &#125;,</span><br><span class="line">                default: &#123;</span><br><span class="line">                    minChunks: 2,</span><br><span class="line">                    priority: -20,</span><br><span class="line">                    reuseExistingChunk: true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Demo源码工程"><a href="#Demo源码工程" class="headerlink" title="Demo源码工程"></a>Demo源码工程</h3><ul>
<li>访问地址：<a href="https://github.com/aa4790139/webpack4_confuse_demo">https://github.com/aa4790139/webpack4_confuse_demo</a></li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.cnblogs.com/tugenhua0707/p/9520780.html">深入浅出的webpack构建工具—-DllPlugin DllReferencePlugin提高构建速度(七)</a></li>
<li><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#optimizationsplitchunks">SplitChunksPlugin 使用说明</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/152097785">Webpack之SplitChunks插件用法详解</a></li>
<li><a href="https://imweb.io/topic/5b66dd601402769b60847149">webpack 4 Code Splitting 的 splitChunks 配置探索</a></li>
</ul>
<blockquote>
<p>以上: 如发现有问题，欢迎留言指出，我及时更正</p>
</blockquote>
]]></content>
      <categories>
        <category>Webpack打包优化</category>
      </categories>
      <tags>
        <tag>DllPlugin</tag>
        <tag>DllReferencePlugin</tag>
      </tags>
  </entry>
</search>
